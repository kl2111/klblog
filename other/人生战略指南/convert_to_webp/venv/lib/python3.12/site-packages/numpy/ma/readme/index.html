<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>开亮人生</title>
<meta name=keywords content><meta name=description content="================================== A Guide to Masked Arrays in NumPy ================================== .. Contents:: See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link) for updates of this document. History ------- As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became increasingly frustrated with the subclassing of masked arrays (even if I can only blame my inexperience). I needed to develop a class of arrays that could store some additional information along with numerical values, while keeping the possibility for missing data (picture storing a series of dates along with measurements, what would later become the `TimeSeries Scikit `__ (dead link)."><meta name=author content="向开亮"><link rel=canonical href=https://www.kailiang.life/other/%E4%BA%BA%E7%94%9F%E6%88%98%E7%95%A5%E6%8C%87%E5%8D%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/readme/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150931964.ico><link rel=icon type=image/png sizes=16x16 href=https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150932794.png><link rel=icon type=image/png sizes=32x32 href=https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150932874.png><link rel=apple-touch-icon href=https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150932247.png><link rel=mask-icon href=https://www.kailiang.life/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.kailiang.life/other/%E4%BA%BA%E7%94%9F%E6%88%98%E7%95%A5%E6%8C%87%E5%8D%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/readme/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content><meta property="og:description" content="================================== A Guide to Masked Arrays in NumPy ================================== .. Contents:: See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link) for updates of this document. History ------- As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became increasingly frustrated with the subclassing of masked arrays (even if I can only blame my inexperience). I needed to develop a class of arrays that could store some additional information along with numerical values, while keeping the possibility for missing data (picture storing a series of dates along with measurements, what would later become the `TimeSeries Scikit `__ (dead link)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.kailiang.life/other/%E4%BA%BA%E7%94%9F%E6%88%98%E7%95%A5%E6%8C%87%E5%8D%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/readme/"><meta property="og:image" content="https://www.kailiang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="other"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.kailiang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content><meta name=twitter:description content="================================== A Guide to Masked Arrays in NumPy ================================== .. Contents:: See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link) for updates of this document. History ------- As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became increasingly frustrated with the subclassing of masked arrays (even if I can only blame my inexperience). I needed to develop a class of arrays that could store some additional information along with numerical values, while keeping the possibility for missing data (picture storing a series of dates along with measurements, what would later become the `TimeSeries Scikit `__ (dead link)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Others","item":"https://www.kailiang.life/other/"},{"@type":"ListItem","position":2,"name":"","item":"https://www.kailiang.life/other/%E4%BA%BA%E7%94%9F%E6%88%98%E7%95%A5%E6%8C%87%E5%8D%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/readme/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"================================== A Guide to Masked Arrays in NumPy ================================== .. Contents:: See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link) for updates of this document. History ------- As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became increasingly frustrated with the subclassing of masked arrays (even if I can only blame my inexperience). I needed to develop a class of arrays that could store some additional information along with numerical values, while keeping the possibility for missing data (picture storing a series of dates along with measurements, what would later become the `TimeSeries Scikit `__ (dead link).","keywords":[],"articleBody":"================================== A Guide to Masked Arrays in NumPy ================================== .. Contents:: See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link) for updates of this document. History ------- As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became increasingly frustrated with the subclassing of masked arrays (even if I can only blame my inexperience). I needed to develop a class of arrays that could store some additional information along with numerical values, while keeping the possibility for missing data (picture storing a series of dates along with measurements, what would later become the `TimeSeries Scikit `__ (dead link). I started to implement such a class, but then quickly realized that any additional information disappeared when processing these subarrays (for example, adding a constant value to a subarray would erase its dates). I ended up writing the equivalent of *numpy.core.ma* for my particular class, ufuncs included. Everything went fine until I needed to subclass my new class, when more problems showed up: some attributes of the new subclass were lost during processing. I identified the culprit as MaskedArray, which returns masked ndarrays when I expected masked arrays of my class. I was preparing myself to rewrite *numpy.core.ma* when I forced myself to learn how to subclass ndarrays. As I became more familiar with the *__new__* and *__array_finalize__* methods, I started to wonder why masked arrays were objects, and not ndarrays, and whether it wouldn't be more convenient for subclassing if they did behave like regular ndarrays. The new *maskedarray* is what I eventually come up with. The main differences with the initial *numpy.core.ma* package are that MaskedArray is now a subclass of *ndarray* and that the *_data* section can now be any subclass of *ndarray*. Apart from a couple of issues listed below, the behavior of the new MaskedArray class reproduces the old one. Initially the *maskedarray* implementation was marginally slower than *numpy.ma* in some areas, but work is underway to speed it up; the expectation is that it can be made substantially faster than the present *numpy.ma*. Note that if the subclass has some special methods and attributes, they are not propagated to the masked version: this would require a modification of the *__getattribute__* method (first trying *ndarray.__getattribute__*, then trying *self._data.__getattribute__* if an exception is raised in the first place), which really slows things down. Main differences ---------------- * The *_data* part of the masked array can be any subclass of ndarray (but not recarray, cf below). * *fill_value* is now a property, not a function. * in the majority of cases, the mask is forced to *nomask* when no value is actually masked. A notable exception is when a masked array (with no masked values) has just been unpickled. * I got rid of the *share_mask* flag, I never understood its purpose. * *put*, *putmask* and *take* now mimic the ndarray methods, to avoid unpleasant surprises. Moreover, *put* and *putmask* both update the mask when needed. * if *a* is a masked array, *bool(a)* raises a *ValueError*, as it does with ndarrays. * in the same way, the comparison of two masked arrays is a masked array, not a boolean * *filled(a)* returns an array of the same subclass as *a._data*, and no test is performed on whether it is contiguous or not. * the mask is always printed, even if it's *nomask*, which makes things easy (for me at least) to remember that a masked array is used. * *cumsum* works as if the *_data* array was filled with 0. The mask is preserved, but not updated. * *cumprod* works as if the *_data* array was filled with 1. The mask is preserved, but not updated. New features ------------ This list is non-exhaustive... * the *mr_* function mimics *r_* for masked arrays. * the *anom* method returns the anomalies (deviations from the average) Using the new package with numpy.core.ma ---------------------------------------- I tried to make sure that the new package can understand old masked arrays. Unfortunately, there's no upward compatibility. For example: \u003e\u003e\u003e import numpy.core.ma as old_ma \u003e\u003e\u003e import maskedarray as new_ma \u003e\u003e\u003e x = old_ma.array([1,2,3,4,5], mask=[0,0,1,0,0]) \u003e\u003e\u003e x array(data = [ 1 2 999999 4 5], mask = [False False True False False], fill_value=999999) \u003e\u003e\u003e y = new_ma.array([1,2,3,4,5], mask=[0,0,1,0,0]) \u003e\u003e\u003e y array(data = [1 2 -- 4 5], mask = [False False True False False], fill_value=999999) \u003e\u003e\u003e x==y array(data = [True True True True True], mask = [False False True False False], fill_value=?) \u003e\u003e\u003e old_ma.getmask(x) == new_ma.getmask(x) array([True, True, True, True, True]) \u003e\u003e\u003e old_ma.getmask(y) == new_ma.getmask(y) array([True, True, False, True, True]) \u003e\u003e\u003e old_ma.getmask(y) False Using maskedarray with matplotlib --------------------------------- Starting with matplotlib 0.91.2, the masked array importing will work with the maskedarray branch) as well as with earlier versions. By default matplotlib still uses numpy.ma, but there is an rcParams setting that you can use to select maskedarray instead. In the matplotlibrc file you will find:: #maskedarray : False # True to use external maskedarray module # instead of numpy.ma; this is a temporary # setting for testing maskedarray. Uncomment and set to True to select maskedarray everywhere. Alternatively, you can test a script with maskedarray by using a command-line option, e.g.:: python simple_plot.py --maskedarray Masked records -------------- Like *numpy.core.ma*, the *ndarray*-based implementation of MaskedArray is limited when working with records: you can mask any record of the array, but not a field in a record. If you need this feature, you may want to give the *mrecords* package a try (available in the *maskedarray* directory in the scipy sandbox). This module defines a new class, *MaskedRecord*. An instance of this class accepts a *recarray* as data, and uses two masks: the *fieldmask* has as many entries as records in the array, each entry with the same fields as a record, but of boolean types: they indicate whether the field is masked or not; a record entry is flagged as masked in the *mask* array if all the fields are masked. A few examples in the file should give you an idea of what can be done. Note that *mrecords* is still experimental... Optimizing maskedarray ---------------------- Should masked arrays be filled before processing or not? -------------------------------------------------------- In the current implementation, most operations on masked arrays involve the following steps: * the input arrays are filled * the operation is performed on the filled arrays * the mask is set for the results, from the combination of the input masks and the mask corresponding to the domain of the operation. For example, consider the division of two masked arrays:: import numpy import maskedarray as ma x = ma.array([1,2,3,4],mask=[1,0,0,0], dtype=numpy.float_) y = ma.array([-1,0,1,2], mask=[0,0,0,1], dtype=numpy.float_) The division of x by y is then computed as:: d1 = x.filled(0) # d1 = array([0., 2., 3., 4.]) d2 = y.filled(1) # array([-1., 0., 1., 1.]) m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m = array([True,False,False,True]) dm = ma.divide.domain(d1,d2) # array([False, True, False, False]) result = (d1/d2).view(MaskedArray) # masked_array([-0. inf, 3., 4.]) result._mask = logical_or(m, dm) Note that a division by zero takes place. To avoid it, we can consider to fill the input arrays, taking the domain mask into account, so that:: d1 = x._data.copy() # d1 = array([1., 2., 3., 4.]) d2 = y._data.copy() # array([-1., 0., 1., 2.]) dm = ma.divide.domain(d1,d2) # array([False, True, False, False]) numpy.putmask(d2, dm, 1) # d2 = array([-1., 1., 1., 2.]) m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m = array([True,False,False,True]) result = (d1/d2).view(MaskedArray) # masked_array([-1. 0., 3., 2.]) result._mask = logical_or(m, dm) Note that the *.copy()* is required to avoid updating the inputs with *putmask*. The *.filled()* method also involves a *.copy()*. A third possibility consists in avoid filling the arrays:: d1 = x._data # d1 = array([1., 2., 3., 4.]) d2 = y._data # array([-1., 0., 1., 2.]) dm = ma.divide.domain(d1,d2) # array([False, True, False, False]) m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m = array([True,False,False,True]) result = (d1/d2).view(MaskedArray) # masked_array([-1. inf, 3., 2.]) result._mask = logical_or(m, dm) Note that here again the division by zero takes place. A quick benchmark gives the following results: * *numpy.ma.divide* : 2.69 ms per loop * classical division : 2.21 ms per loop * division w/ prefilling : 2.34 ms per loop * division w/o filling : 1.55 ms per loop So, is it worth filling the arrays beforehand ? Yes, if we are interested in avoiding floating-point exceptions that may fill the result with infs and nans. No, if we are only interested into speed... Thanks ------ I'd like to thank Paul Dubois, Travis Oliphant and Sasha for the original masked array package: without you, I would never have started that (it might be argued that I shouldn't have anyway, but that's another story...). I also wish to extend these thanks to Reggie Dugard and Eric Firing for their suggestions and numerous improvements. Revision notes -------------- * 08/25/2007 : Creation of this page * 01/23/2007 : The package has been moved to the SciPy sandbox, and is regularly updated: please check out your SVN version! ","wordCount":"1479","inLanguage":"zh","image":"https://www.kailiang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"向开亮"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.kailiang.life/other/%E4%BA%BA%E7%94%9F%E6%88%98%E7%95%A5%E6%8C%87%E5%8D%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/readme/"},"publisher":{"@type":"Organization","name":"开亮人生","logo":{"@type":"ImageObject","url":"https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150931964.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.kailiang.life/ accesskey=h title="开亮人生 (Alt + H)"><img src=https://ouyoung.oss-cn-zhangjiakou.aliyuncs.com/202310150932247.png alt aria-label=logo height=35>开亮人生</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.kailiang.life/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.kailiang.life/categories/%E5%BF%83%E7%90%86%E4%BC%A0%E8%AE%B0/ title=心理传记・人生叙事><span>心理传记・人生叙事</span></a></li><li><a href=https://www.kailiang.life/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://www.kailiang.life/archives/ title="📂 归档"><span>📂 归档</span></a></li><li><a href=https://www.kailiang.life/search/ title="🔎 搜索 (Alt + /)" accesskey=/><span>🔎 搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.kailiang.life/>主页</a>&nbsp;»&nbsp;<a href=https://www.kailiang.life/other/>Others</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>向开亮&nbsp;|&nbsp;<a href=https://github.com/KL2111/klblog/edit/main/content//other/%e4%ba%ba%e7%94%9f%e6%88%98%e7%95%a5%e6%8c%87%e5%8d%97/convert_to_webp/venv/lib/python3.12/site-packages/numpy/ma/README.rst rel="noopener noreferrer" target=_blank>SuggestChanges</a></div></header><div class=post-content>==================================
A Guide to Masked Arrays in NumPy
==================================
.. Contents::
See http://www.scipy.org/scipy/numpy/wiki/MaskedArray (dead link)
for updates of this document.
History
-------
As a regular user of MaskedArray, I (Pierre G.F. Gerard-Marchant) became
increasingly frustrated with the subclassing of masked arrays (even if
I can only blame my inexperience). I needed to develop a class of arrays
that could store some additional information along with numerical values,
while keeping the possibility for missing data (picture storing a series
of dates along with measurements, what would later become the `TimeSeries
Scikit <http://projects.scipy.org/scipy/scikits/wiki/timeseries>`__
(dead link).
I started to implement such a class, but then quickly realized that
any additional information disappeared when processing these subarrays
(for example, adding a constant value to a subarray would erase its
dates). I ended up writing the equivalent of *numpy.core.ma* for my
particular class, ufuncs included. Everything went fine until I needed to
subclass my new class, when more problems showed up: some attributes of
the new subclass were lost during processing. I identified the culprit as
MaskedArray, which returns masked ndarrays when I expected masked
arrays of my class. I was preparing myself to rewrite *numpy.core.ma*
when I forced myself to learn how to subclass ndarrays. As I became more
familiar with the *__new__* and *__array_finalize__* methods,
I started to wonder why masked arrays were objects, and not ndarrays,
and whether it wouldn't be more convenient for subclassing if they did
behave like regular ndarrays.
The new *maskedarray* is what I eventually come up with. The
main differences with the initial *numpy.core.ma* package are
that MaskedArray is now a subclass of *ndarray* and that the
*_data* section can now be any subclass of *ndarray*. Apart from a
couple of issues listed below, the behavior of the new MaskedArray
class reproduces the old one. Initially the *maskedarray*
implementation was marginally slower than *numpy.ma* in some areas,
but work is underway to speed it up; the expectation is that it can be
made substantially faster than the present *numpy.ma*.
Note that if the subclass has some special methods and
attributes, they are not propagated to the masked version:
this would require a modification of the *__getattribute__*
method (first trying *ndarray.__getattribute__*, then trying
*self._data.__getattribute__* if an exception is raised in the first
place), which really slows things down.
Main differences
----------------
* The *_data* part of the masked array can be any subclass of ndarray (but not recarray, cf below).
* *fill_value* is now a property, not a function.
* in the majority of cases, the mask is forced to *nomask* when no value is actually masked. A notable exception is when a masked array (with no masked values) has just been unpickled.
* I got rid of the *share_mask* flag, I never understood its purpose.
* *put*, *putmask* and *take* now mimic the ndarray methods, to avoid unpleasant surprises. Moreover, *put* and *putmask* both update the mask when needed. * if *a* is a masked array, *bool(a)* raises a *ValueError*, as it does with ndarrays.
* in the same way, the comparison of two masked arrays is a masked array, not a boolean
* *filled(a)* returns an array of the same subclass as *a._data*, and no test is performed on whether it is contiguous or not.
* the mask is always printed, even if it's *nomask*, which makes things easy (for me at least) to remember that a masked array is used.
* *cumsum* works as if the *_data* array was filled with 0. The mask is preserved, but not updated.
* *cumprod* works as if the *_data* array was filled with 1. The mask is preserved, but not updated.
New features
------------
This list is non-exhaustive...
* the *mr_* function mimics *r_* for masked arrays.
* the *anom* method returns the anomalies (deviations from the average)
Using the new package with numpy.core.ma
----------------------------------------
I tried to make sure that the new package can understand old masked
arrays. Unfortunately, there's no upward compatibility.
For example:
>>> import numpy.core.ma as old_ma
>>> import maskedarray as new_ma
>>> x = old_ma.array([1,2,3,4,5], mask=[0,0,1,0,0])
>>> x
array(data =
[ 1 2 999999 4 5],
mask =
[False False True False False],
fill_value=999999)
>>> y = new_ma.array([1,2,3,4,5], mask=[0,0,1,0,0])
>>> y
array(data = [1 2 -- 4 5],
mask = [False False True False False],
fill_value=999999)
>>> x==y
array(data =
[True True True True True],
mask =
[False False True False False],
fill_value=?)
>>> old_ma.getmask(x) == new_ma.getmask(x)
array([True, True, True, True, True])
>>> old_ma.getmask(y) == new_ma.getmask(y)
array([True, True, False, True, True])
>>> old_ma.getmask(y)
False
Using maskedarray with matplotlib
---------------------------------
Starting with matplotlib 0.91.2, the masked array importing will work with
the maskedarray branch) as well as with earlier versions.
By default matplotlib still uses numpy.ma, but there is an rcParams setting
that you can use to select maskedarray instead. In the matplotlibrc file
you will find::
#maskedarray : False # True to use external maskedarray module
# instead of numpy.ma; this is a temporary #
setting for testing maskedarray.
Uncomment and set to True to select maskedarray everywhere.
Alternatively, you can test a script with maskedarray by using a
command-line option, e.g.::
python simple_plot.py --maskedarray
Masked records
--------------
Like *numpy.core.ma*, the *ndarray*-based implementation
of MaskedArray is limited when working with records: you can
mask any record of the array, but not a field in a record. If you
need this feature, you may want to give the *mrecords* package
a try (available in the *maskedarray* directory in the scipy
sandbox). This module defines a new class, *MaskedRecord*. An
instance of this class accepts a *recarray* as data, and uses two
masks: the *fieldmask* has as many entries as records in the array,
each entry with the same fields as a record, but of boolean types:
they indicate whether the field is masked or not; a record entry
is flagged as masked in the *mask* array if all the fields are
masked. A few examples in the file should give you an idea of what
can be done. Note that *mrecords* is still experimental...
Optimizing maskedarray
----------------------
Should masked arrays be filled before processing or not?
--------------------------------------------------------
In the current implementation, most operations on masked arrays involve
the following steps:
* the input arrays are filled
* the operation is performed on the filled arrays
* the mask is set for the results, from the combination of the input masks and the mask corresponding to the domain of the operation.
For example, consider the division of two masked arrays::
import numpy
import maskedarray as ma
x = ma.array([1,2,3,4],mask=[1,0,0,0], dtype=numpy.float_)
y = ma.array([-1,0,1,2], mask=[0,0,0,1], dtype=numpy.float_)
The division of x by y is then computed as::
d1 = x.filled(0) # d1 = array([0., 2., 3., 4.])
d2 = y.filled(1) # array([-1., 0., 1., 1.])
m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m =
array([True,False,False,True])
dm = ma.divide.domain(d1,d2) # array([False, True, False, False])
result = (d1/d2).view(MaskedArray) # masked_array([-0. inf, 3., 4.])
result._mask = logical_or(m, dm)
Note that a division by zero takes place. To avoid it, we can consider
to fill the input arrays, taking the domain mask into account, so that::
d1 = x._data.copy() # d1 = array([1., 2., 3., 4.])
d2 = y._data.copy() # array([-1., 0., 1., 2.])
dm = ma.divide.domain(d1,d2) # array([False, True, False, False])
numpy.putmask(d2, dm, 1) # d2 = array([-1., 1., 1., 2.])
m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m =
array([True,False,False,True])
result = (d1/d2).view(MaskedArray) # masked_array([-1. 0., 3., 2.])
result._mask = logical_or(m, dm)
Note that the *.copy()* is required to avoid updating the inputs with
*putmask*. The *.filled()* method also involves a *.copy()*.
A third possibility consists in avoid filling the arrays::
d1 = x._data # d1 = array([1., 2., 3., 4.])
d2 = y._data # array([-1., 0., 1., 2.])
dm = ma.divide.domain(d1,d2) # array([False, True, False, False])
m = ma.mask_or(ma.getmask(x), ma.getmask(y)) # m =
array([True,False,False,True])
result = (d1/d2).view(MaskedArray) # masked_array([-1. inf, 3., 2.])
result._mask = logical_or(m, dm)
Note that here again the division by zero takes place.
A quick benchmark gives the following results:
* *numpy.ma.divide* : 2.69 ms per loop
* classical division : 2.21 ms per loop
* division w/ prefilling : 2.34 ms per loop
* division w/o filling : 1.55 ms per loop
So, is it worth filling the arrays beforehand ? Yes, if we are interested
in avoiding floating-point exceptions that may fill the result with infs
and nans. No, if we are only interested into speed...
Thanks
------
I'd like to thank Paul Dubois, Travis Oliphant and Sasha for the
original masked array package: without you, I would never have started
that (it might be argued that I shouldn't have anyway, but that's
another story...). I also wish to extend these thanks to Reggie Dugard
and Eric Firing for their suggestions and numerous improvements.
Revision notes
--------------
* 08/25/2007 : Creation of this page
* 01/23/2007 : The package has been moved to the SciPy sandbox, and is regularly updated: please check out your SVN version!</div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.kailiang.life/>开亮人生</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>